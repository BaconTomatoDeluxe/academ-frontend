'use client';

import axios, { AxiosHeaders, AxiosResponse } from 'axios';
import { AxiosError } from 'axios';
import { AxiosRequestConfig } from 'axios';

import { useEffect, useState } from 'react';
import { JWT } from '@/lib/models/user';

const backend = axios.create({
  baseURL: process.env.NEXT_PUBLIC_BACKEND_API_URL,
  maxRedirects: 0,
  withCredentials: true,
});

class ApiError extends Error {
  code: number | undefined;

  constructor(code?: number) {
    super();
    this.code = code;
  }
}

const buildUrlWithParams = (baseUrl: string, req: Record<string, string | number>) => {
  const newReq = Object.keys(req).reduce((acc: Record<string, string>, key) => {
    acc[key] = String(req[key]);
    return acc;
  }, {});
  const params = new URLSearchParams(newReq).toString();
  return params !== '' ? `${baseUrl}?${params}` : baseUrl;
};

export type ApiResponse<T> =
  | {
      status: 'SUCCESS' | 'ERROR';
      code: number;
      data: T;
      message: string;
      version: string;
    }
  | {
      status: 'FAILURE';
      code: number;
      data: 'NO_RES' | 'NO_REQ' | 'FAIL_RES';
      message: string;
      version: string;
    };

function failWith(data: 'NO_RES' | 'NO_REQ' | 'FAIL_RES', message: string, code: number): ApiResponse<any> {
  return {
    status: 'FAILURE',
    code,
    data,
    message,
    version: 'NO VERSION, This response was generated by Academ Fronted',
  };
}

/**
 * Api 요청시 함께 보낼 수 있는 Context
 *
 */
export interface ApiCTX {
  token?: {
    accessToken: JWT;
    refreshToken?: JWT;
  };
}

/**
 * AxiosResponse Promise를 받아서 항상 resolve된 버전의 Promise로 바꿔줌
 */
function resolvify<Res>(promise: Promise<AxiosResponse<ApiResponse<Res>, any>>) {
  return promise
    .then((res) => {
      const data: ApiResponse<Res> = res.data;
      data.code = res.status;
      return Promise.resolve(res.data as ApiResponse<Res>);
    })
    .catch((error: AxiosError) => {
      if (error.response) {
        return Promise.resolve(failWith('FAIL_RES', '실패한 응답을 받았습니다.', error.response.status));
      } else if (error.request) {
        return Promise.resolve(
          failWith(
            'NO_RES',
            '응답을 수신하지 못했습니다. 장치가 네트워크에 연결되어 있지 않거나 서버가 오프라인입니다.',
            -2,
          ),
        );
      } else {
        return Promise.resolve(
          failWith('NO_REQ', '요청을 전송하지 못했습니다. 장치가 네트워크에 연결 되지 않았나요?', -3),
        );
      }
    })
    .catch(() => {
      return Promise.resolve(failWith('NO_REQ', '알 수 없는 오류', -4));
    });
}

/**
 * build : automatically generates api call functions
 *
 * @param method
 * @param path
 * @param config
 * @returns
 */
export function build<Req, Res>(method: 'POST' | 'GET', path: string, config: AxiosRequestConfig = {}) {
  return async function (req: Req, ctx?: ApiCTX): Promise<ApiResponse<Res>> {
    (function prepareConfig() {
      if (config.headers === undefined) {
        config.headers = {};
      }

      if (ctx?.token !== undefined) {
        config.headers.Authorization = `Bearer ${ctx.token.accessToken}`;
      }
    })();

    const firstTry =
      method === 'POST'
        ? backend.post(path, req, {
            ...{
              validateStatus: (status: number) => (status >= 200 && status < 500) || allowedStatus.includes(status),
            },
            ...config,
          })
        : backend.get(buildUrlWithParams(path, req as Record<string, string | number>), {
            ...{
              validateStatus: (status: number) => (status >= 200 && status < 500) || allowedStatus.includes(status),
            },
            ...config,
          });

    const firstResult = await resolvify<Res>(firstTry);

    return firstResult;
  };
}

export function createApiHook<Req, Res>(apicall: (a: Req, ctx?: ApiCTX) => Promise<ApiResponse<Res>>) {
  return function (req: Req, ctx?: ApiCTX): ApiResponse<Res> | null {
    const [r, setR] = useState<ApiResponse<Res> | null>(null);

    useEffect(() => {
      apicall(req, ctx).then((a) => setR(a));
    }, []);

    return r;
  };
}
